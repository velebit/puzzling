#!/usr/bin/perl
use warnings;
use strict;
use Text::Wrap;

use lib '../lib';
use LetterPattern;
use Cypher::Decode;
use Cypher::Encode;

## input

@ARGV = ('cyphertext-200412');
my $key = '';
my (%data, @data, %cat);
while (<>) {
  s/[\r\n]+//g;
  /^\s+(.+)\s*$/ and $key = lc $1, next;
  /\S/ or next;
  push @{$data{$key}}, $_;
  push @data, $_;
  $cat{$_} = $key;
}
$data{''} = \@data;

## read first name db

my @fname_files = qw( bert/english.names.first bert/misc.names.first
                      bert/extra.names.first );
my (%fnames, %fnames_by_len);

$fnames{''}    = read_prefixed_words '..',    @fname_files;
$fnames{men}   = read_prefixed_words '[^w].', @fname_files;
$fnames{women} = read_prefixed_words '[^m].', @fname_files;

for my $cat (keys %fnames) {
  $_ = lc $_,
    push @{ $fnames_by_len{$cat}{length $_} }, $_
      foreach @{ $fnames{$cat} };
}

## read full name db

my @aname_files = qw( ../english/english.names ../english/misc.names
                      bert/extra.names.last );
my ($anames, %anames_by_len);

$anames = read_words @aname_files;

$_ = lc $_
  foreach @$anames;
#  push @{ $anames_by_len{length $_} }, $_

## read cached cypher relationships, generated by imdb-attack-actor.pl

our $cyphers = {};
require 'cyphers-200412.data' if -f 'cyphers-200412.data';
my (%name2movie, %name2cyphgen, %name_capitalize, %movie_year);
$name2movie{lc $_} = $cyphers->{$_}[0],
  $name2cyphgen{lc $_} = $cyphers->{$_}[1],
    $movie_year{$cyphers->{$_}[0]} = $cyphers->{$_}[2],
    $name_capitalize{lc $_} = $_ for keys %$cyphers;

## special cases

print "names not matching '<word> <word>':\n";
print "  $_   ($cat{$_})\n" for grep !/^[A-Z]+ [A-Z]+$/, @data;

## overall frequencies

print "\n";
my (%cat_freq, %cat_freq_order);

for my $cat (sort keys %data) {
  $cat_freq{$cat}{$_}++ foreach map split(//), @{$data{$cat}};
  my @order = sort {$cat_freq{$cat}{$b} <=> $cat_freq{$cat}{$a}}
    keys %{$cat_freq{$cat}};
  $cat_freq_order{$cat} = \@order;
  my $cols = 4;
  my $rows = int((@order + $cols - 1) / $cols);
  printf "letter frequencies for %s (%d total chars):",
    ($cat || 'all'), scalar @order;
  for my $r (0..($rows-1)) {
    for my $c (0..($cols-1)) {
      print($c ? "   " : "\n  ");
      my $p = $c*$rows + $r;
      $p >= @order and next;
      printf qq[%2d "%s"], $cat_freq{$cat}{$order[$p]}, $order[$p];
    }
  }
  print "\n";
}

## numbers of delta candidates

sub squote ( $ ) { $_[0] =~ /'/ ? qq["$_[0]"] : qq['$_[0]']; }
sub dquote ( $ ) { $_[0] =~ /"/ ? qq['$_[0]'] : qq["$_[0]"]; }
sub pquote ( $ ) { qq[($_[0])]; }
sub bquote ( $ ) { qq<[$_[0]]>; }

#print "\n";
#for my $cat (sort keys %fnames_by_len) {
#  printf "number of known first names by length, for %s:\n", ($cat || 'all');
#  for my $len (sort {$a<=>$b} keys %{ $fnames_by_len{$cat} }) {
#    printf "  %2d: %5s\n", $len, bquote @{ $fnames_by_len{$cat}{$len} };
#  }
#}

## first names

my (%first, %first_by_len);

print "\n";
for my $cat (sort keys %data) {
  for my $name (@{$data{$cat}}) {
    my ($first) = split ' ', $name;
    push @{ $first{$cat} }, $first;
    push @{ $first_by_len{$cat}{length $first} }, $first;
  }

  printf "first names (by length) for %s, compared w/ num. known (k):\n",
    ($cat || 'all');
  for my $len (sort {$a<=>$b} keys %{$first_by_len{$cat}}) {
    printf "  %1d: k=%3s %3s", $len, scalar @{ $fnames_by_len{$cat}{$len} },
      bquote @{ $first_by_len{$cat}{$len} };
    print " $_" for sort @{ $first_by_len{$cat}{$len} };
    print "\n";
  }
}

## 'good' munged first names to attack

my (%munged, %munged_score);

print "\n";
for my $cat (sort grep length, keys %first) {
  foreach my $cyp (@{ $first{$cat} }) {
    my @cletters = split //, $cyp;
    my %ccount;
    ++$ccount{$_} for @cletters;
    $munged{$cyp} = join '',
      sort {$ccount{$b} <=> $ccount{$a} or $a cmp $b} @cletters;
    my $score = 0;
    $score += ($_-.9)*($_-.9) for values %ccount;
    $munged_score{$cyp} = $score;
  }
  my @order = sort {$munged_score{$b} <=> $munged_score{$a}
		      or length $a <=> length $b
			or $munged{$a} cmp $munged{$b}}
    @{ $first{$cat} };
  my $cols = 2;
  my $rows = int((@order + $cols - 1) / $cols);
  printf "sorted-letter first names for %s (%d total words):",
    ($cat || 'all'), scalar @order;
  for my $r (0..($rows-1)) {
    for my $c (0..($cols-1)) {
      print($c ? "   " : "\n  ");
      my $p = $c*$rows + $r;
      $p >= @order and next;
      my $cyp = $order[$p];
      my @lcyp = split //, $cyp;
      my %ccyp;
      ++$ccyp{$_} for @lcyp;
      my $scy = join '', sort {$ccyp{$b} <=> $ccyp{$a} or $a cmp $b} @lcyp;
      printf "%-15s %-17s", $scy, pquote $cyp;
    }
  }
  print "\n";
}

## marginally less stupid guesswork attempt =)

if (0) {
print "\ntry a few names:\n";
for my $T ( 'm winston churchill', 'w margaret thatcher', 'm isaac newton',
            'm albert einstein', 'm tony blair', 'm david beckham',
	    'm alec guinness', 'w mata hari', 'm santa claus',
	    'm george smiley', 'm john lecarre',
	    'm james bond', 'm ian fleming',
	    'm gregory peck', 'm harrison ford', 'm humphrey bogart',
	    'm sean connery', 'm roger moore' ) {
  (my $t = $T) =~ s/^([mw]) // or die;
  my $cat = ($1 eq 'm' ? 'men' : 'women');
  my $m = template_find uc($t), $data{''}
    or print("  no possibilities for '$t'\n"), next;
  print "  possible '$t':\n";
  printf "    %-15s %-7s\n", $_, pquote $cat{$_} for @$m;
}
}

## dictionary attack on first names

my $dverbose = 1;

# when there are multiple matches, we have to use this hardcoded list
# of actual actors to help us out. ;)
my @good = ( 'humphrey bogart', 'harrison ford', 'anthony hopkins',
	     'gregory peck', 'audrey hepburn', 'elizabeth taylor',
	     'jodie foster', 'rex harrison', 'tony curtis', 'richard burton',
	     'ingrid bergman', 'kelly mcgillis', 'charles laughton',
	     'sean connery', 'albert finney', 'lauren bacall', 'ewan mcgregor',
	     'nicole kidman', 'mickey rooney', 'judy garland', 'kim basinger',
	     'kevin spacey', 'bill murray', 'carrie fisher', 'alec guinness',
	     'jack lemmon', 'kirsten dunst', 'tobey maguire', 'john hurt',
	     'sigourney weaver'
	   );

sub show_matches ( $$$ ) {
  my ($what, $tmpl, $matches) = @_;
  if ($dverbose) {
    if ((my $n = @$matches) > 20) {
      print "      $what matches for '$tmpl' <$n> -- skipped.\n";
    } else {
      local $Text::Wrap::columns = 60;
      print "      $what matches for '$tmpl' <$n>:\n",
	wrap(' ' x 8, ' ' x 8, sort(@$matches), "\n");
    }
  }
}

my (@match_list, %match_name);

print "\ndictionary (or known-good) name matches:\n";
for my $cat (sort grep length, keys %data) {
  my $c0 = substr $cat, 1;
  for my $name (@{ $data{$cat} }) {
    my ($match);
    if (my $good = template_find $name, \@good) {
      # If on the list of known-good names, accept immediately.
      @$good == 1 or die;
      $match = $good->[0];
    } else {
      # Otherwise, try finding the first name...
      my ($first, $last) = split ' ', $name, 2;
      my $f_maybe = template_find $first, $fnames{$cat};
      # ...and the last name...
      my $l_maybe = template_find $last, $anames;

      # (verify matches)
      $f_maybe or $l_maybe
	or print("  no name matches for '$name' ($cat).\n"), next;
      $f_maybe or print("  no first-name matches for '$first' ($cat).\n"),
	show_matches('last-name', $last, $l_maybe), next;
      $l_maybe or print("  no last-name matches for '$last'.\n"),
	show_matches('first-name', $first, $f_maybe), next;
      #my $fm = join '|',
      #  (@$f_maybe < 5 ? @$f_maybe
      #   : (@$f_maybe[0..3], "... " . bquote scalar @$f_maybe ) );

      # ...then try finding first+last combos that don't conflict.
      my @combos;
      for my $f (@$f_maybe) {
	push @combos, "$f $_" for @$l_maybe;
      }
      my $maybe = template_find $name, \@combos
	or print("  no combined matches for '$name' ($cat).\n"),
	  show_matches('first-name', $first, $f_maybe),
	    show_matches('last-name', $last, $l_maybe), next;
      if (@$maybe > 1) {
	if (@$maybe > 200) {
	  print "  possible  '$name' ($cat) [" . @$maybe . "] -- skipped.\n";
	} else {
	  print "  possible  '$name' ($cat) [" . @$maybe . "]:\n";
	  print "    $_\n" for @$maybe;
	}
	next;
      }
      $match = $maybe->[0];
    }

    # If we're here, we have a single, hopefully good, name match.
    printf "  match for %-40s %s\n", "'$name' ($cat):", $match;
    #print "  match for '$name' ($cat):  $match\n";
    push @match_list, [ $name, $match, $cat ];
    $match_name{$name} = $match;
  }
}

### show match-list cyphers

if (0) {
  print "\nmatch cyphers:\n";
  for my $m (0..$#match_list) {
    my ($name, $match, $cat) = @{$match_list[$m]};
    printf "  %-30s -> %s\n", squote $name, squote $match;
    my $C = Cypher::Decode->new($name, $match);
    print($C->display('    -> '), $C->invert->display('    <- '));
  }
}

my %pair;
print "\ncompatible cyphers:\n";
for my $m (0..($#match_list-1)) {
  my ($name1, $match1, $cat1) = @{$match_list[$m]};
  my $C1 = Cypher::Decode->new($name1, $match1);
  for my $n (($m+1)..$#match_list) {
    my ($name2, $match2, $cat2) = @{$match_list[$n]};
    my $C2 = Cypher::Decode->new($name2, $match2);
    $C2->compatible($C1) or next;
    Cypher::Decode->new($name2, $match2)->compatible($C1) or next;
    printf "  %-30s -> %s\n", squote $name1, squote $match1;
    printf "  %-30s -> %s\n", squote $name2, squote $match2;
    #print($C1->display('        -> '));
    #print($C2->display('        -> '));
    $C2->combine_with($C1);
    print($C2->display('        -> '), $C2->invert->display('        <- '));
    push @{$pair{$match1}}, $match2;
    push @{$pair{$match2}}, $match1;
  }
}

## cyphers that we don't have a compat match for

if (0) {
  print "\ncyphers with no compat matches (yet):\n";
  for my $m (0..$#match_list) {
    my ($name, $match, $cat) = @{$match_list[$m]};
    exists $pair{$match} and next;
    printf "  %-30s -> %s\n", squote $name, squote $match;
  }
}

## show solved names, corresponding cyphers, and movies

sub center ( $;$ ) {
  my ($text, $wid) = @_;
  $wid = 80 unless $wid;
  ' ' x int(($wid - length($text) - 1) / 2) . $text;
}

if (0) {
  my $end = $#{$data{men}};
  $end = $#{$data{women}} if $end < $#{$data{women}};

  print "\n\n", center('*** solution (as listed) ***'), "\n";
  printf "%-40s%s\n\n", '---MEN---', '---WOMEN---';
  for my $i (0..$end) {
    my $m_code  = $data{men}[$i];
    my $m_name  = $match_name{$m_code} or die;
    my $m_cname = $name_capitalize{$m_name} || $m_name;
    my $m_movie = $name2movie{$m_name} || '???';
    my $m_cyph  = $name2cyphgen{$m_name} || '???';

    my $w_code  = $data{women}[$i];
    my $w_name  = $match_name{$w_code} or die;
    my $w_cname = $name_capitalize{$w_name} || $w_name;
    my $w_movie = $name2movie{$w_name} || '???';
    my $w_cyph  = $name2cyphgen{$w_name} || '???';

    printf "%-40s%s\n",   $m_cname, $w_cname;
    printf "  %-40s%s\n", $m_movie, $w_movie;
    printf "  %-40s%s\n", $m_cyph,  $w_cyph;
    print "\n";
  }
}

## show solved names, corresponding cyphers, and movies -- by movie

my (%minfo);
for my $code (@data) {
  my $name  = $match_name{$code} or die;
  my $cname = $name_capitalize{$name} || $name;
  my $movie = $name2movie{$name} or next;
  my $cyph  = $name2cyphgen{$name} or next;
  my $mw    = $cat{$code};
  my $year  = $movie_year{$movie} || '';

  ! exists $minfo{$movie}{$mw}
    or die "Movie conflict: $minfo{$movie}{$mw}{name} vs $name ($mw)";
  ! exists $minfo{$movie}{cyphgen} or $minfo{$movie}{cyphgen} eq $cyph
    or die "Inconsistent cyphergen text";

  $minfo{$movie}{$mw}     = { name => $cname, code => $code };
  $minfo{$movie}{cyphgen} = $cyph;
  $minfo{$movie}{year}    = $year;
}

if (1) {
  print "\n", center('*** solution (by movie) ***', 40), "\n";
  printf "%-20s%20s\n\n", '---MEN---', '---WOMEN---';
  for my $movie (sort keys %minfo) {
    my $m_name  = $minfo{$movie}{men}{name};
    my $w_name  = $minfo{$movie}{women}{name};
    my $cyph    = $minfo{$movie}{cyphgen};

    printf "%-20s%20s\n",   $m_name, $w_name;
    printf "%s\n", center($movie, 40);
    printf "%s\n", center($cyph, 40);
    printf "%s\n", center($Cypher::Base::atoz, 40);
    print "\n";
  }
}

## write names, movies and cyphers to a file

my $DELIM = '#';

open my $S, '>', 'SOLUTION-200412' or die "open(>): $!";
for my $movie (sort keys %minfo) {
  my $m_name  = $minfo{$movie}{men}{name};
  my $w_name  = $minfo{$movie}{women}{name};
  my $cyph    = $minfo{$movie}{cyphgen};
  my $year    = $minfo{$movie}{year};

  print $S join($DELIM, $movie, $m_name, $w_name, $cyph, $year) . "\n";
}
close $S;
